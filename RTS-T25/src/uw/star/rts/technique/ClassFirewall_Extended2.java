package uw.star.rts.technique;


import java.util.List;
import java.util.Map;



import org.slf4j.*;

import uw.star.rts.analysis.DependencyAnalyzer_C2CInboundTransitive;
import uw.star.rts.artifact.Application;
import uw.star.rts.artifact.ClassEntity;
import uw.star.rts.artifact.Program;

public class ClassFirewall_Extended2 extends ClassFirewall {
	DependencyAnalyzer_C2CInboundTransitive dp;

	public ClassFirewall_Extended2(){
		log = LoggerFactory.getLogger(ClassFirewall_Extended2.class.getName());
	}
	@Override
	public void setApplication(Application app) {
		super.setApplication(app);
		dp = new DependencyAnalyzer_C2CInboundTransitive(); //this call will clean up previous files generated by DependencyFinder tool
	}

	/**
	 * This is different from ClassFirewall_Extended as it re-analyzes dependency information for each new version
	 * General procedure:
	 * 1. Collect code coverage data of v0
	 * 2. Compare MD5 signatures to produce a list of changed classes between v0 and v1
	 * 3. Collect dependency data of changed classes 
	 * 4. Extract test cases that use the change classes or use classes that are directly or transitively dependent on changed classes
	 * e.g. coverage only needs to analyze on v0.
	 * this method is assumed to be called in sequence of program versions, i.e. call selectTests(v0,v1) first , then selectTests(v1,v2) etc...
	 * collect direct dependent and transitive dependent information of changed classes
	 */
	Map<ClassEntity,List<String>> collectDependentInformation(Program p,List<ClassEntity> changedClassesCurrentVer){

			dp.analyze(p); 
			return dp.findDirectAndTransitiveInBoundDependentClasses(changedClassesCurrentVer);
	}
}