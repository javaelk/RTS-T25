package uw.star.rts.technique;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.LoggerFactory;

import uw.star.rts.analysis.DependencyAnalyzer_C2CInbound;
import uw.star.rts.analysis.DependencyAnalyzer_C2CInboundTransitive;
import uw.star.rts.artifact.Application;
import uw.star.rts.artifact.ClassEntity;
import uw.star.rts.artifact.Program;

public class ClassFirewall_Direct extends ClassFirewall {
	DependencyAnalyzer_C2CInbound dp;
	
	public ClassFirewall_Direct(){
		log = LoggerFactory.getLogger(ClassFirewall_Direct.class.getName());
	}
	
	@Override
	public void setApplication(Application app) {
	super.setApplication(app);
	dp = new DependencyAnalyzer_C2CInbound(); //this call will clean up previous files generated by DependencyFinder tool
	}
	
	
	
	/**
	 * collect direct dependent information of changed classes
	 * This implementation always re-analyze dependency information of all classes, regardless of the program version.
	 *  
	 * General procedure:
	 * 1. Collect code coverage data of v0
	 * 2. Compare MD5 signatures to produce a list of changed classes between p and pPrime
	 * 3. Collect dependency data of changed classes 
	 * 4. Extract test cases that use the change classes or use classes that are directly dependent on changed classes
	 * 
	 * this method is assumed to be called in sequence of program versions, i.e. call selectTests(v0,v1) first , then selectTests(v1,v2) etc...
	 */
	
	Map<ClassEntity,List<String>> collectDependentInformation(Program p,List<ClassEntity> changedClasses){
			dp.analyze(p); 
			return dp.findDirectDependentClasses(changedClasses);
	}
}
